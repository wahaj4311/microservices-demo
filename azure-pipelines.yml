trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - terraform/**

variables:
  # Container registry service connection
  dockerRegistryServiceConnection: 'acr-service-connection'
  imageRepository: 'microservices-demo'
  containerRegistry: '$(ACR_LOGIN_SERVER)'
  tag: '$(Build.BuildId)'
  
  # Kubernetes service connection
  kubernetesServiceConnection: 'aks-service-connection'
  namespace: 'microservices-demo'
  
  # AKS cluster information
  resourceGroupName: 'microservices-demo-dev-rg'
  clusterName: 'microservices-demo-dev-aks'

stages:
- stage: Build
  displayName: Build and Push
  jobs:
  - job: BuildAndPush
    displayName: Build and Push
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Bash@3
      displayName: Configure logging
      inputs:
        targetType: 'inline'
        script: |
          echo "Starting build process at $(date)"
          echo "Build ID: $(Build.BuildId)"
          echo "Branch: $(Build.SourceBranch)"

    # Build and push all services in a loop
    - bash: |
        services=("api-gateway" "auth-service" "product-service" "order-service")
        for service in "${services[@]}"; do
          echo "Building $service..."
          docker build -t $(containerRegistry)/$(imageRepository)/$service:$(tag) $service/
          echo "Pushing $service..."
          docker push $(containerRegistry)/$(imageRepository)/$service:$(tag)
          echo "$service build and push completed"
        done
      displayName: 'Build and Push Services'

# =====================================================================
# DEPLOYMENT STAGE
# The following changes were made to fix deployment issues:
# 1. Changed container ports from 80 to correct application ports:
#    - API Gateway: 8000 (was 80)
#    - Auth Service: 8001 (was 80)
#    - Product Service: 8002 (was 80)
#    - Order Service: 8003 (was 80)
# 
# 2. Changed service ports to match application ports:
#    - API Gateway: 8000 (was 80)
#    - Auth Service: 8001 (was 80)
#    - Product Service: 8002 (was 80)
#    - Order Service: 8003 (was 80)
#
# 3. Added required environment variables for each service:
#    - Database connection strings
#    - Redis URLs
#    - Service URLs for inter-service communication
#
# 4. Added imagePullSecrets to all deployments
#
# 5. Removed health checks to prevent circular dependencies
# =====================================================================
- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: Build
  jobs:
  - deployment: DeployToAKS
    displayName: Deploy to AKS
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: Bash@3
            displayName: Debug and Logging
            inputs:
              targetType: 'inline'
              script: |
                echo "Starting deployment at $(date)"
                echo "Namespace: $(namespace)"
                echo "Cluster: $(clusterName)"
                kubectl version --client
                
          - task: AzureCLI@2
            displayName: Get AKS Credentials
            inputs:
              azureSubscription: 'azure-subscription-service-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Getting AKS credentials..."
                az aks get-credentials --resource-group $(resourceGroupName) --name $(clusterName) --admin --overwrite-existing
                kubectl create namespace $(namespace) --dry-run=client -o yaml | kubectl apply -f -
                echo "Namespace status:"
                kubectl get namespace $(namespace)

          # Update image tags in k8s manifests
          - task: Bash@3
            displayName: Update K8s Manifests
            inputs:
              targetType: 'inline'
              script: |
                services=("api-gateway" "auth-service" "product-service" "order-service")
                for service in "${services[@]}"; do
                  echo "Updating $service manifests..."
                  sed -i "s|image:.*|image: $(containerRegistry)/$(imageRepository)/$service:$(tag)|g" k8s/base/$service/deployment.yaml
                done

          # Apply k8s manifests
          - task: Kubernetes@1
            displayName: Deploy Services
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: 'azure-subscription-service-connection'
              azureResourceGroup: '$(resourceGroupName)'
              kubernetesCluster: '$(clusterName)'
              namespace: '$(namespace)'
              command: 'apply'
              arguments: '-R -f k8s/base/'

          - task: Bash@3
            displayName: Verify Deployment
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking deployment status..."
                kubectl get pods -n $(namespace)
                kubectl get services -n $(namespace)
                echo "Deployment completed at $(date)" 