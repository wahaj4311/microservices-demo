trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - terraform/**

variables:
  # Container registry service connection
  dockerRegistryServiceConnection: 'acr-service-connection'
  imageRepository: 'microservices-demo'
  containerRegistry: '$(ACR_LOGIN_SERVER)'
  tag: '$(Build.BuildId)'
  
  # Kubernetes service connection
  kubernetesServiceConnection: 'aks-service-connection'
  namespace: 'microservices-demo'
  
  # AKS cluster information
  resourceGroupName: 'microservices-demo-dev-rg'
  clusterName: 'microservices-demo-dev-aks'

stages:
- stage: Build
  displayName: Build and Push
  jobs:
  - job: BuildAndPush
    displayName: Build and Push
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      fetchDepth: 1
      
    - task: Bash@3
      displayName: Configure logging
      inputs:
        targetType: 'inline'
        script: |
          echo "Starting build process at $(date)"
          echo "Build ID: $(Build.BuildId)"
          echo "Branch: $(Build.SourceBranch)"

    # Build and push all services in a loop
    - bash: |
        services=("api-gateway" "auth-service" "product-service" "order-service")
        for service in "${services[@]}"; do
          echo "Building $service..."
          docker build -t $(containerRegistry)/$(imageRepository)/$service:$(tag) $service/
          echo "Pushing $service..."
          docker push $(containerRegistry)/$(imageRepository)/$service:$(tag)
          echo "$service build and push completed"
        done
      displayName: 'Build and Push Services'

# =====================================================================
# DEPLOYMENT STAGE
# The following changes were made to fix deployment issues:
# 1. Changed container ports from 80 to correct application ports:
#    - API Gateway: 8000 (was 80)
#    - Auth Service: 8001 (was 80)
#    - Product Service: 8002 (was 80)
#    - Order Service: 8003 (was 80)
# 
# 2. Changed service ports to match application ports:
#    - API Gateway: 8000 (was 80)
#    - Auth Service: 8001 (was 80)
#    - Product Service: 8002 (was 80)
#    - Order Service: 8003 (was 80)
#
# 3. Added required environment variables for each service:
#    - Database connection strings
#    - Redis URLs
#    - Service URLs for inter-service communication
#
# 4. Added imagePullSecrets to all deployments
#
# 5. Removed health checks to prevent circular dependencies
# =====================================================================
- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: Build
  jobs:
  - deployment: DeployToAKS
    displayName: Deploy to AKS
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            fetchDepth: 1
            
          - task: Bash@3
            displayName: Debug and Logging
            inputs:
              targetType: 'inline'
              script: |
                echo "Starting deployment at $(date)"
                echo "Namespace: $(namespace)"
                echo "Cluster: $(clusterName)"
                kubectl version --client
                
          - task: AzureCLI@2
            displayName: Get AKS Credentials
            inputs:
              azureSubscription: 'azure-subscription-service-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Getting AKS credentials..."
                az aks get-credentials --resource-group $(resourceGroupName) --name $(clusterName) --admin --overwrite-existing
                kubectl create namespace $(namespace) --dry-run=client -o yaml | kubectl apply -f -
                echo "Namespace status:"
                kubectl get namespace $(namespace)

          # Update image tags in k8s manifests
          - task: Bash@3
            displayName: Debug Charts Directory
            inputs:
              targetType: 'inline'
              script: |
                echo "Current directory: $(pwd)"
                echo "Listing workspace directory:"
                ls -la
                echo "Listing charts directory:"
                ls -R charts/
                
          - task: Bash@3
            displayName: Update K8s Manifests
            inputs:
              targetType: 'inline'
              script: |
                services=("api-gateway" "auth-service" "product-service" "order-service")
                for service in "${services[@]}"; do
                  echo "Updating $service manifests..."
                  sed -i "s|image:.*|image: $(containerRegistry)/$(imageRepository)/$service:$(tag)|g" charts/microservices/templates/$service/deployment.yaml
                done

          # Debug Helm and chart
          - task: Bash@3
            displayName: Debug Helm Setup
            inputs:
              targetType: 'inline'
              script: |
                echo "Helm version:"
                helm version
                echo "Helm list:"
                helm list -n $(namespace)
                echo "Checking for stuck releases..."
                if helm list -n $(namespace) | grep -q "pending-"; then
                  echo "Found stuck releases, cleaning up..."
                  for release in $(helm list -n $(namespace) -q); do
                    helm status $release -n $(namespace)
                    helm uninstall $release -n $(namespace) || true
                  done
                fi
                echo "Validating chart:"
                helm lint ./charts/microservices
                echo "Template validation:"
                helm template --debug ./charts/microservices

          # Apply k8s manifests using Helm
          - task: HelmDeploy@0
            displayName: Deploy Services with Helm
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscription: 'azure-subscription-service-connection'
              azureResourceGroup: '$(resourceGroupName)'
              kubernetesCluster: '$(clusterName)'
              namespace: '$(namespace)'
              command: 'upgrade'
              chartType: 'FilePath'
              chartPath: './charts/microservices'
              releaseName: 'microservices-demo'
              install: true
              force: true
              waitForExecution: true
              arguments: >
                --create-namespace 
                --timeout 10m0s 
                --debug 
                --dry-run 
                --atomic 
                --cleanup-on-fail 
                --set containerRegistry=$(containerRegistry) 
                --set imageRepository=$(imageRepository) 
                --set tag=$(tag)

          # If dry run succeeds, do the actual deployment
          - task: HelmDeploy@0
            displayName: Deploy Services with Helm (Actual)
            condition: succeeded()
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscription: 'azure-subscription-service-connection'
              azureResourceGroup: '$(resourceGroupName)'
              kubernetesCluster: '$(clusterName)'
              namespace: '$(namespace)'
              command: 'upgrade'
              chartType: 'FilePath'
              chartPath: './charts/microservices'
              releaseName: 'microservices-demo'
              install: true
              force: true
              waitForExecution: true
              arguments: >
                --create-namespace 
                --timeout 10m0s 
                --atomic 
                --cleanup-on-fail 
                --set containerRegistry=$(containerRegistry) 
                --set imageRepository=$(imageRepository) 
                --set tag=$(tag)

          - task: Bash@3
            displayName: Verify Deployment
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking deployment status..."
                kubectl get pods -n $(namespace)
                kubectl get services -n $(namespace)
                echo "Deployment completed at $(date)" 